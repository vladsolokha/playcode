why is insertion-sort or radix-sort better than quick/merge/heap in certain cases?
ignore bubble-sort

implement quick sort (O(n log(n))
implement merge sort (O(n log(n))

implement tree - it has heirarchial (not linear) structure. 
binary tree - has left and right nodes
n-ary tree - can have n children nodes for each node
trie-tree - information retrieval data structure. =) can search key in O(M) linear time where M=string length =( expensive storage reqs. Binary tree has O(M*log(n)) time reqs. Multiple branches, each node represents character and branch represents key with last node marked isEndOfWord = True.  

balanced binary trees - 
red/black tree 
splay tree 
AVL tree - each node contains balance factor who's value is either -1, 0, +1. 
Balance Factor = height of left sub tree - height of right subtree
Balance Factor = height of right sub tree - height of left subtree


tree traversal algorithms
dfs - depth, go deep, search down to leaves -> backtrack to root -> down to next branch, implement via stack / recursion
preorder - root, left, left, right, right (i.e.: print, if left? if right?)
inorder - left, middle, right, root (i.e.: if left? print if right?)
postorder - left, right, middle, root (i.e.: if left? if right? print)
bfs - breadth don't go deep, search root -> neighbor nodes -> level based search, implement via a queue

how data is transfered between websites?

watch life in appEngine production
(this video from Life at Google)[https://youtu.be/_8cH-QPVXsw]

(what happens when you hit enter on a browser search bar)[http://continuations.com/post/15615918569/tech-tuesday-how-the-web-works-overview]

## Linux/Unix
kernels
regular expressions
system calls
permissions
file-systems

## Operating systems
processes and what resources it needs
threads
concurrency issues
locks
mutexes
semaphores
monitors
deadlock
livelock
context switching

## SQL/Databases
ETL

# Be competitive
**At software jobs**
(Ideal Coding BootCamp by Raymond Gan)[https://www.linkedin.com/pulse/my-ideal-coding-bootcamp-raymond-gan/]

[ ] Do at least 100 problems in Codility, HackerRank, Project Euler, or LeetCode following strig O(time/space) standards.

[ ] Write software tests for everything

[ ] Read and code from scratch a FULL software book on your chosen language with no peeking

[ ] (Build Your Own X)[https://github.com/rayning0/build-your-own-x]

[ ] (Open-source projects for beginners)[https://github.com/rayning0/awesome-for-beginners]

[ ] (Code solutions to sample beginner projects)[https://github.com/rayning0/Projects-Solutions]

[ ] Build to meet customer demand

[ ] Push code daily